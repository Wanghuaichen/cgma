COMPILING APPLICATIONS USING CGM (WITH OR WITHOUT ACIS)

CGM has been modified to simplify its use in application codes, and to
allow linking with or without ACIS, using the same set of compiled CGM
libraries.  This allows us to maintain a single version of the CGM
libraries for use in both ACIS-enabled and facet-only applications.
This note contains information on linking CGM into applications,
either with or without ACIS.  These applications are assumed to be
written in C++; to link other applications, they must be called from a 
C++ main program (examples of doing this are available).

To review, CGM consists of three primary libraries: libcubit_list.a,
libcubit_util.a, and libcubit_geom.a.  In addition, there are several
other geometry-specific libraries in CGM, including libcubit_ACIS.a
and libcubit_facet.a.  CUBIT links all of these libraries, in addition
to the ACIS libraries.  These libraries are found in the 'geom'
and 'util' subdirectories, and in subdirectories of 'geom'.
These directories should have a common parent directory, which is
typically the directory in which the rest of CUBIT source code is
found.

LINKING CGM WITHOUT ACIS

To link CGM, applications must define the make variable
CGM_DIR, which is the directory directly *above* the 'geom' and
'util' subdirectories in the CGM directory structure.
Following this definition, the application makefile should include the
'config.make' file, which contains other definitions needed to link
CGM.  This file is generated by the configure script for CGM.  After
this, follow the directions in the top of ${CGM_DIR}/config.make.

WRITING CGM FACET-BASED APPLICATIONS

Writing an application which uses CGM for facet-based modeling is
quite simple.  In a nutshell, the application needs to:

- make a list of points and facets defining the surface(s) in the
model
- pass these to GeometryTool::make_facet_surface, which returns a
Surface pointer
- pass the Surface pointer to GeometryTool::make_facet_shell, and pass 
the results of that along to GeometryTool::make_facet_lump and
GeometryTool::make_facet_body

With that, you have a Body pointer, and associated volumes and
surfaces, which can be evaluated for closest point, normals, etc.  For 
example, you can get a pointer to the first RefFace and evaluate it
for closest point and normal using:

  RefFace *face = GeometryTool::instance()->get_first_ref_face();
  CubitVector test_position, result_position, normal;
  test_position.set(10.0, 0, 0);
  face->find_closest_point_trimmed(test_position, result_position);
  normal = face->normal_at(result_position);

A very simple driver code, which defines a facet-based model
consisting of one surface, with facets from a right tetrahedron with
points at the origin and unit distance along each coordinate axis, and 
evaluates this model, is available.  It is a grand total of 151 lines, 
including point and facet data, comments and include statements.
Please contact Tim Tautges at tjtautg@sandia.gov if you would like a
copy of this code.

WRITING CGM ACIS-BASED APPLICATIONS

Acis-based applications are just as simple to write as facet-based
ones.  If you use the instructions in ${CGM_DIR}/config.make, there
should be no change to your Makefile.  In your code, you should create
an AcisQueryEngine object before initializing CGM:

   AcisQueryEngine *aqe = AcisQueryEngine::instance();
   GeometryQueryTool *gqt = GeometryQueryTool::instance();

After initializing the GeometryQueryTool, you can use it to import solid
model files, get topological entities like faces and edges, etc., as
described in the CGM report.


